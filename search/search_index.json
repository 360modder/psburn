{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PsBurn - Powershell Script Packager psburn is a tool to package powershell scripts into executables by binding it with a c# or python program. Quick Start Github Repository","title":"Home"},{"location":"#psburn-powershell-script-packager","text":"psburn is a tool to package powershell scripts into executables by binding it with a c# or python program. Quick Start Github Repository","title":"PsBurn - Powershell Script Packager"},{"location":"changelog/","text":"Changelog 1.1.3 (20/09/2021) Features: Added support to merge dll and exe using ILMerge Changes: Command line api is simplified and left with two commands only Argument parsing is done by PsburnCliParser.dll csharp_binder.cs now depends on PsburnCliParser.dll which depends on SharpZipLib Removed usage, examples and variables parsing from #@parser descriptor Removed no extract feature Fixed: Argument parsing techniques 1.0.0 (22/06/2021) Features: Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#113-20092021","text":"Features: Added support to merge dll and exe using ILMerge Changes: Command line api is simplified and left with two commands only Argument parsing is done by PsburnCliParser.dll csharp_binder.cs now depends on PsburnCliParser.dll which depends on SharpZipLib Removed usage, examples and variables parsing from #@parser descriptor Removed no extract feature Fixed: Argument parsing techniques","title":"1.1.3 (20/09/2021)"},{"location":"changelog/#100-22062021","text":"Features: Initial release","title":"1.0.0 (22/06/2021)"},{"location":"documentation/argparse/","text":"Argparse psburn has a feature called argparse integration which allows to integrate argparse to powershell scripts. Also check this example . Note All #@ descriptors should be in one line. #@parser Base descriptor for program. Syntax #@parser {description: \"psburn parser-cli demo\"} Properties Key Type description string #@param Arguments and parameter descriptor for program. Syntax #@param {variable: \"verbose\", alias: \"v\", value: \"false\", type: \"bool\", required: \"false\", help: \"enable or disable logging\"} Properties Key Type Values variable string alias char or string value string type string string, double or bool required string true or false help string Note If Values cell is blank it means any value can be assigned. Warning hyphens are not supported in variable instead use underscore.","title":"Argparse"},{"location":"documentation/argparse/#argparse","text":"psburn has a feature called argparse integration which allows to integrate argparse to powershell scripts. Also check this example . Note All #@ descriptors should be in one line.","title":"Argparse"},{"location":"documentation/argparse/#parser","text":"Base descriptor for program.","title":"#@parser"},{"location":"documentation/argparse/#syntax","text":"#@parser {description: \"psburn parser-cli demo\"}","title":"Syntax"},{"location":"documentation/argparse/#properties","text":"Key Type description string","title":"Properties"},{"location":"documentation/argparse/#param","text":"Arguments and parameter descriptor for program.","title":"#@param"},{"location":"documentation/argparse/#syntax_1","text":"#@param {variable: \"verbose\", alias: \"v\", value: \"false\", type: \"bool\", required: \"false\", help: \"enable or disable logging\"}","title":"Syntax"},{"location":"documentation/argparse/#properties_1","text":"Key Type Values variable string alias char or string value string type string string, double or bool required string true or false help string Note If Values cell is blank it means any value can be assigned. Warning hyphens are not supported in variable instead use underscore.","title":"Properties"},{"location":"documentation/build/","text":"Build build command provides a set of toolchains for building executables with c# and python with powershell scripts. Shell psburn build -h build build an executable from binder file Usage: psburn [options] build <psscript> <binderfile> Arguments: <psscript> path of powershell script <binderfile> path of binder file Options: -p, --powershell-zip <powershell-zip> create a powershell core self contained executable [default: no zip] -r, --resources-zip <resources-zip> embed resources from a zip file [default: no zip] --onedir run powershell executable from root directory for self contained builds [default: False] --icon <icon> icon path for executable [default: no icon] --no-console create executable without a console (gui) [default: False] --uac-admin request elevation upon application restart (windows specific) [default: False] --cscpath <cscpath> csc/c# compiler path (C:\\Windows\\Microsoft.Net\\Framework\\<version>\\csc.exe) [default: auto detect] --merge merge dll and exe using ILMerge [default: False] --pyinstaller-prompt ask for extra pyinstaller arguments [default: False] -d, --debug don't delete runtime generated files [default: False] --verbose generate more outputs and logs than usual [default: False] -?, -h, --help Show help and usage information","title":"Build"},{"location":"documentation/build/#build","text":"build command provides a set of toolchains for building executables with c# and python with powershell scripts.","title":"Build"},{"location":"documentation/build/#shell","text":"psburn build -h build build an executable from binder file Usage: psburn [options] build <psscript> <binderfile> Arguments: <psscript> path of powershell script <binderfile> path of binder file Options: -p, --powershell-zip <powershell-zip> create a powershell core self contained executable [default: no zip] -r, --resources-zip <resources-zip> embed resources from a zip file [default: no zip] --onedir run powershell executable from root directory for self contained builds [default: False] --icon <icon> icon path for executable [default: no icon] --no-console create executable without a console (gui) [default: False] --uac-admin request elevation upon application restart (windows specific) [default: False] --cscpath <cscpath> csc/c# compiler path (C:\\Windows\\Microsoft.Net\\Framework\\<version>\\csc.exe) [default: auto detect] --merge merge dll and exe using ILMerge [default: False] --pyinstaller-prompt ask for extra pyinstaller arguments [default: False] -d, --debug don't delete runtime generated files [default: False] --verbose generate more outputs and logs than usual [default: False] -?, -h, --help Show help and usage information","title":"Shell"},{"location":"documentation/create/","text":"Create create command is used to generate c# and python binder file for powershell script. Shell psburn create -h create create a binder c# or python file Usage: psburn [options] create <psscript> Arguments: <psscript> path of powershell script Options: -o, --output <output> path for output of c# or python file [default: working directory] --py generate python binder file instead of c# [default: False] --self-contained enable this option if you are using --powershell-zip [default: False] --embed-resources enable this option if you are using --resources-zip [default: False] --onedir run powershell executable from root directory for self contained builds [default: False] --execution-policy <execution-policy> script execution policy [default: Bypass] --block-cat block script cat feature at runtime [default: False] --verbose generate more outputs and logs than usual [default: False] -?, -h, --help Show help and usage information","title":"Create"},{"location":"documentation/create/#create","text":"create command is used to generate c# and python binder file for powershell script.","title":"Create"},{"location":"documentation/create/#shell","text":"psburn create -h create create a binder c# or python file Usage: psburn [options] create <psscript> Arguments: <psscript> path of powershell script Options: -o, --output <output> path for output of c# or python file [default: working directory] --py generate python binder file instead of c# [default: False] --self-contained enable this option if you are using --powershell-zip [default: False] --embed-resources enable this option if you are using --resources-zip [default: False] --onedir run powershell executable from root directory for self contained builds [default: False] --execution-policy <execution-policy> script execution policy [default: Bypass] --block-cat block script cat feature at runtime [default: False] --verbose generate more outputs and logs than usual [default: False] -?, -h, --help Show help and usage information","title":"Shell"},{"location":"documentation/runtime/","text":"Runtime During runtime psburn updates and creates some of powershell script variables to use them in script. Variable Values Type $PSScriptRoot Same path where executable is located string $PSScriptTempRoot Original path of extracted script string $Executable Path of powershell executable string","title":"Runtime"},{"location":"documentation/runtime/#runtime","text":"During runtime psburn updates and creates some of powershell script variables to use them in script. Variable Values Type $PSScriptRoot Same path where executable is located string $PSScriptTempRoot Original path of extracted script string $Executable Path of powershell executable string","title":"Runtime"},{"location":"gettingstarted/argparseintegration/","text":"Argparse Integration psburn can easily integrate argparse to your powershell script. python's argparse is fully matured module to do this stuff but in c# its scratch implemented which is similar to python argparse. Syntax Integrating argparse is very simple, you just have to write one line json descriptors in your powershell script. Learn More #@parser {description: \"gretting program\"} #@param {variable: \"name\", alias: \"n\", required: \"true\", help: \"name to greet\"} #@param {variable: \"twice\", alias: \"t\", value: \"false\", type: \"bool\", required: \"false\", help: \"greet person two times\"} Write-Output \"$name you may have a good day\" if ( $twice ) { Write-Output \"$name you may have a good day second time\" } Results Now if you package script and run the compiled executable with -h flag, you will see this help message. greet -h C# usage: greet [-h] [-t] [--cat] name gretting program positional arguments: name name to greet optional arguments: -t, --twice greet person two times [default: false] --cat instead of running cat powershell script into console [default: false] -h, --help show this help message and exit Python usage: greet [-h] [-t] [--cat] name gretting program positional arguments: name name to greet optional arguments: -h, --help show this help message and exit -t, --twice greet person two times [default: false] --cat instead of running cat powershell script into console [default: false]","title":"Argparse Integration"},{"location":"gettingstarted/argparseintegration/#argparse-integration","text":"psburn can easily integrate argparse to your powershell script. python's argparse is fully matured module to do this stuff but in c# its scratch implemented which is similar to python argparse.","title":"Argparse Integration"},{"location":"gettingstarted/argparseintegration/#syntax","text":"Integrating argparse is very simple, you just have to write one line json descriptors in your powershell script. Learn More #@parser {description: \"gretting program\"} #@param {variable: \"name\", alias: \"n\", required: \"true\", help: \"name to greet\"} #@param {variable: \"twice\", alias: \"t\", value: \"false\", type: \"bool\", required: \"false\", help: \"greet person two times\"} Write-Output \"$name you may have a good day\" if ( $twice ) { Write-Output \"$name you may have a good day second time\" }","title":"Syntax"},{"location":"gettingstarted/argparseintegration/#results","text":"Now if you package script and run the compiled executable with -h flag, you will see this help message. greet -h C# usage: greet [-h] [-t] [--cat] name gretting program positional arguments: name name to greet optional arguments: -t, --twice greet person two times [default: false] --cat instead of running cat powershell script into console [default: false] -h, --help show this help message and exit Python usage: greet [-h] [-t] [--cat] name gretting program positional arguments: name name to greet optional arguments: -h, --help show this help message and exit -t, --twice greet person two times [default: false] --cat instead of running cat powershell script into console [default: false]","title":"Results"},{"location":"gettingstarted/installations/","text":"Installations Since psburn is a cross platform tool, its binaries are distributed for windows, linux and macos. Binaries are compressed inside a zip and tarball file. You first need to choose a building envoirnment mentioned below. Then you can install psburn from binary archive to your system. Building Envoirnments Building envoirnments are necessary to build a executable out a file using psburn. Choose one such envoirnment from python and c#. python envoirnment is recommended on linux and macos and c# on windows. Python python3.6+ and pip should be installed, then install pyinstaller. pip install pyinstaller C# Windows does't require any C# envoirnment as it comes integrated with .NET Framework but on linux and macos a compatible version of mono should be installed. Download Windows Binary Archives Binary archives installations steps on linux and macos. Linux # Download the psburn '.tar.gz' archive curl -L -o /tmp/psburn.tar.gz https://github.com/clitic/psburn/releases/download/v1.1.3/psburn.1.1.3.linux-x64.tar.gz # Create the target folder where psburn will be placed sudo mkdir -p /opt/clitic/psburn # Expand psburn to the target folder sudo tar zxf /tmp/psburn.tar.gz -C /opt/clitic/psburn # Set execute permissions sudo chmod +x /opt/clitic/psburn/psburn # Create the symbolic link that points to psburn sudo ln -s /opt/clitic/psburn/psburn /usr/bin/psburn # Uninstall binary archive # sudo rm -rf /usr/bin/psburn/psburn /opt/clitic/psburn MacOS # Download the psburn '.tar.gz' archive curl -L -o /tmp/psburn.tar.gz https://github.com/clitic/psburn/releases/download/v1.1.3/psburn.1.1.3.osx-x64.tar.gz # Create the target folder where psburn will be placed sudo mkdir -p /usr/local/clitic/psburn # Expand psburn to the target folder sudo tar zxf /tmp/psburn.tar.gz -C /usr/local/clitic/psburn # Set execute permissions sudo chmod +x /usr/local/clitic/psburn/psburn # Create the symbolic link that points to psburn sudo ln -s /usr/local/clitic/psburn/psburn /usr/local/bin/psburn # Uninstall binary archive # sudo rm -rf /usr/local/bin/psburn /usr/local/clitic/psburn","title":"Installations"},{"location":"gettingstarted/installations/#installations","text":"Since psburn is a cross platform tool, its binaries are distributed for windows, linux and macos. Binaries are compressed inside a zip and tarball file. You first need to choose a building envoirnment mentioned below. Then you can install psburn from binary archive to your system.","title":"Installations"},{"location":"gettingstarted/installations/#building-envoirnments","text":"Building envoirnments are necessary to build a executable out a file using psburn. Choose one such envoirnment from python and c#. python envoirnment is recommended on linux and macos and c# on windows. Python python3.6+ and pip should be installed, then install pyinstaller. pip install pyinstaller C# Windows does't require any C# envoirnment as it comes integrated with .NET Framework but on linux and macos a compatible version of mono should be installed.","title":"Building Envoirnments"},{"location":"gettingstarted/installations/#download","text":"Windows","title":"Download"},{"location":"gettingstarted/installations/#binary-archives","text":"Binary archives installations steps on linux and macos. Linux # Download the psburn '.tar.gz' archive curl -L -o /tmp/psburn.tar.gz https://github.com/clitic/psburn/releases/download/v1.1.3/psburn.1.1.3.linux-x64.tar.gz # Create the target folder where psburn will be placed sudo mkdir -p /opt/clitic/psburn # Expand psburn to the target folder sudo tar zxf /tmp/psburn.tar.gz -C /opt/clitic/psburn # Set execute permissions sudo chmod +x /opt/clitic/psburn/psburn # Create the symbolic link that points to psburn sudo ln -s /opt/clitic/psburn/psburn /usr/bin/psburn # Uninstall binary archive # sudo rm -rf /usr/bin/psburn/psburn /opt/clitic/psburn MacOS # Download the psburn '.tar.gz' archive curl -L -o /tmp/psburn.tar.gz https://github.com/clitic/psburn/releases/download/v1.1.3/psburn.1.1.3.osx-x64.tar.gz # Create the target folder where psburn will be placed sudo mkdir -p /usr/local/clitic/psburn # Expand psburn to the target folder sudo tar zxf /tmp/psburn.tar.gz -C /usr/local/clitic/psburn # Set execute permissions sudo chmod +x /usr/local/clitic/psburn/psburn # Create the symbolic link that points to psburn sudo ln -s /usr/local/clitic/psburn/psburn /usr/local/bin/psburn # Uninstall binary archive # sudo rm -rf /usr/local/bin/psburn /usr/local/clitic/psburn","title":"Binary Archives"},{"location":"gettingstarted/packagepsscripts/","text":"Package Powershell Scripts If you are on windows then c# api works without any dependencies, means you can run commands without installing any other dependencies. To use python api, pyinstaller must be installed on your system. Packaging Generate binder file to run powershell scripts with program. psburn create script.ps1 This command will generated a c# binder file named after the basename of your powershell script. Now build a executable out of this file by running build command. psburn build script.ps1 script.cs Your powershell script will be packaged under dist folder of working directory. Use mkbundle to bundle exe if you are using mono. To package scripts using python, just add --py flag in create command to generate python binder file instead of c#. psburn create script.ps1 --py psburn build script.ps1 script.py Merging dll and exe files If you use c# binder file to build a executable then it generates dll which are required by executable to run properly, you can merge this dll and exe using ilmerge or ilrepack . You can also use --merge flag on windows, which will use ilmerge to merge dll and exe. psburn build script.ps1 script.cs --merge Windows ILMerge /o:a.exe main_file.exe PsburnCliParser.dll ICSharpCode.SharpZipLib.dll Linux/MacOS mono ILRepack.exe /o:a.exe main_file.exe PsburnCliParser.dll ICSharpCode.SharpZipLib.dll Access more options with build command You can access more options like icon, name etc. while build executables with build command, just add --pyinstaller-prompt flag to your build command. Then you will be prompted to supply extra arguments to pyinstaller. You can check pyinstaller help for available options. pyinstaller -h Oops got an error while building an executable, what to do ? Error: csc path not found In linux and macos you will get this error, fix this error by adding --cscpath csc flag in build command.","title":"Package Powershell Scripts"},{"location":"gettingstarted/packagepsscripts/#package-powershell-scripts","text":"If you are on windows then c# api works without any dependencies, means you can run commands without installing any other dependencies. To use python api, pyinstaller must be installed on your system.","title":"Package Powershell Scripts"},{"location":"gettingstarted/packagepsscripts/#packaging","text":"Generate binder file to run powershell scripts with program. psburn create script.ps1 This command will generated a c# binder file named after the basename of your powershell script. Now build a executable out of this file by running build command. psburn build script.ps1 script.cs Your powershell script will be packaged under dist folder of working directory. Use mkbundle to bundle exe if you are using mono. To package scripts using python, just add --py flag in create command to generate python binder file instead of c#. psburn create script.ps1 --py psburn build script.ps1 script.py","title":"Packaging"},{"location":"gettingstarted/packagepsscripts/#merging-dll-and-exe-files","text":"If you use c# binder file to build a executable then it generates dll which are required by executable to run properly, you can merge this dll and exe using ilmerge or ilrepack . You can also use --merge flag on windows, which will use ilmerge to merge dll and exe. psburn build script.ps1 script.cs --merge Windows ILMerge /o:a.exe main_file.exe PsburnCliParser.dll ICSharpCode.SharpZipLib.dll Linux/MacOS mono ILRepack.exe /o:a.exe main_file.exe PsburnCliParser.dll ICSharpCode.SharpZipLib.dll","title":"Merging dll and exe files"},{"location":"gettingstarted/packagepsscripts/#access-more-options-with-build-command","text":"You can access more options like icon, name etc. while build executables with build command, just add --pyinstaller-prompt flag to your build command. Then you will be prompted to supply extra arguments to pyinstaller. You can check pyinstaller help for available options. pyinstaller -h","title":"Access more options with build command"},{"location":"gettingstarted/packagepsscripts/#oops-got-an-error-while-building-an-executable-what-to-do","text":"Error: csc path not found In linux and macos you will get this error, fix this error by adding --cscpath csc flag in build command.","title":"Oops got an error while building an executable, what to do ?"},{"location":"gettingstarted/workflow/","text":"Workflow psburn itself does't compile the powershell scripts but it encapulates the script inside a c# or python program and then compile those programs with specific toolchains. Commands psburn comes with two methods for compiling scripts, the first one is using c# compiler (mono on linux/macos) and the second one is using python and pyinstaller. create command generates specific binding code for your script to run, then you can build a executable from those files using build . What happens during execution of packaged powershell script ? Since psburn doesn't actually compile powershell script it stores a copy of powershell script inside it as embedded resource and extract this script to a temporary directory and run it from there.","title":"Workflow"},{"location":"gettingstarted/workflow/#workflow","text":"psburn itself does't compile the powershell scripts but it encapulates the script inside a c# or python program and then compile those programs with specific toolchains.","title":"Workflow"},{"location":"gettingstarted/workflow/#commands","text":"psburn comes with two methods for compiling scripts, the first one is using c# compiler (mono on linux/macos) and the second one is using python and pyinstaller. create command generates specific binding code for your script to run, then you can build a executable from those files using build . What happens during execution of packaged powershell script ? Since psburn doesn't actually compile powershell script it stores a copy of powershell script inside it as embedded resource and extract this script to a temporary directory and run it from there.","title":"Commands"},{"location":"usage/creatingselfcontainedexecutable/","text":"Creating Self Contained Executable psburn can also build self contained executables, means that you need not to install powershell on every system. It uses powershell core to do this. For making self contained executables the main recipe is a zip file which contains os specific powershell core binaries. Preparing A Zip You can download the latest binary archives of powershell core of your system from official github repository of powershell . Windows Invoke-WebRequest https :// github . com / PowerShell / PowerShell / releases / download / v7 . 1 . 3 / PowerShell - 7 . 1 . 3-win-x64 . zip -o PowerShell - 7 . 1 . 3-win-x64 . zip After downloading the binary archive you will have to extract all files inside a directory named pwsh . Expand-Archive -Path PowerShell - 7 . 1 . 3-win-x64 . zip -DestinationPath pwsh Linux wget https://github.com/PowerShell/PowerShell/releases/download/v7.1.3/powershell-7.1.3-linux-x64.tar.gz -O powershell-7.1.3-linux-x64.tar.gz After downloading the binary archive you will have to extract all files inside a directory named pwsh . mkdir pwsh && tar -xf powershell-7.1.3-linux-x64.tar.gz -C pwsh MacOS wget https://github.com/PowerShell/PowerShell/releases/download/v7.1.3/powershell-7.1.3-osx-x64.tar.gz -O powershell-7.1.3-osx-x64.tar.gz After downloading the binary archive you will have to extract all files inside a folder named pwsh . mkdir pwsh && tar -xf powershell-7.1.3-osx-x64.tar.gz -C pwsh You should attain this type of directory structure. pwsh/ *.dll # dll files. *.so # lib files. *.exe # exe files. ... # other files and folders. Now compress pwsh directory into a zip file. Windows Compress-Archive -Path pwsh -DestinationPath pwsh . zip Linux/MacOS zip -r pwsh.zip pwsh Building Executable psburn create script.ps1 --self-contained psburn build script.ps1 script.cs -p pwsh.zip Note Zip compression level can make executable large or small size for only c# builds. Note Use --onedir flag in all commands for faster booting time of packaged scripts.","title":"Creating Self Contained Executable"},{"location":"usage/creatingselfcontainedexecutable/#creating-self-contained-executable","text":"psburn can also build self contained executables, means that you need not to install powershell on every system. It uses powershell core to do this. For making self contained executables the main recipe is a zip file which contains os specific powershell core binaries.","title":"Creating Self Contained Executable"},{"location":"usage/creatingselfcontainedexecutable/#preparing-a-zip","text":"You can download the latest binary archives of powershell core of your system from official github repository of powershell . Windows Invoke-WebRequest https :// github . com / PowerShell / PowerShell / releases / download / v7 . 1 . 3 / PowerShell - 7 . 1 . 3-win-x64 . zip -o PowerShell - 7 . 1 . 3-win-x64 . zip After downloading the binary archive you will have to extract all files inside a directory named pwsh . Expand-Archive -Path PowerShell - 7 . 1 . 3-win-x64 . zip -DestinationPath pwsh Linux wget https://github.com/PowerShell/PowerShell/releases/download/v7.1.3/powershell-7.1.3-linux-x64.tar.gz -O powershell-7.1.3-linux-x64.tar.gz After downloading the binary archive you will have to extract all files inside a directory named pwsh . mkdir pwsh && tar -xf powershell-7.1.3-linux-x64.tar.gz -C pwsh MacOS wget https://github.com/PowerShell/PowerShell/releases/download/v7.1.3/powershell-7.1.3-osx-x64.tar.gz -O powershell-7.1.3-osx-x64.tar.gz After downloading the binary archive you will have to extract all files inside a folder named pwsh . mkdir pwsh && tar -xf powershell-7.1.3-osx-x64.tar.gz -C pwsh You should attain this type of directory structure. pwsh/ *.dll # dll files. *.so # lib files. *.exe # exe files. ... # other files and folders. Now compress pwsh directory into a zip file. Windows Compress-Archive -Path pwsh -DestinationPath pwsh . zip Linux/MacOS zip -r pwsh.zip pwsh","title":"Preparing A Zip"},{"location":"usage/creatingselfcontainedexecutable/#building-executable","text":"psburn create script.ps1 --self-contained psburn build script.ps1 script.cs -p pwsh.zip Note Zip compression level can make executable large or small size for only c# builds. Note Use --onedir flag in all commands for faster booting time of packaged scripts.","title":"Building Executable"},{"location":"usage/embeddingresources/embeddingresources/","text":"Embedding Resources psburn can embed resources to your powershell script. You just need to place all files inside one directory and you can access the path to those files by using $PSScriptRoot and $PSScriptTempRoot . Suppose you created a directory structure like this. resources/ message.txt You can access message.txt path by a function. function resource_path ( [string] $resourcefile ) { Join-Path $PSScriptTempRoot $resourcefile } $message_file = resource_path ( \"resources/message.txt\" ) Write-Output $message_file For build the executable, first compress resources directory to a zip file and then run the following commands. psburn create script.ps1 --embed-resources psburn build script.ps1 script.cs -r resources.zip","title":"Embedding Resources"},{"location":"usage/embeddingresources/embeddingresources/#embedding-resources","text":"psburn can embed resources to your powershell script. You just need to place all files inside one directory and you can access the path to those files by using $PSScriptRoot and $PSScriptTempRoot . Suppose you created a directory structure like this. resources/ message.txt You can access message.txt path by a function. function resource_path ( [string] $resourcefile ) { Join-Path $PSScriptTempRoot $resourcefile } $message_file = resource_path ( \"resources/message.txt\" ) Write-Output $message_file For build the executable, first compress resources directory to a zip file and then run the following commands. psburn create script.ps1 --embed-resources psburn build script.ps1 script.cs -r resources.zip","title":"Embedding Resources"},{"location":"usage/embeddingresources/invokesubscripts/","text":"Invoke Sub Scripts You can also invoke multiple sub scripts from a single executable by using $Executable in your powershell script which stores the path for powershell executable. Test Create directory structure like this. app.ps1 # main psscript resources/ setup.ps1 # sub script 1 clean.ps1 # sub script 2 Contents of scripts. app.ps1 function resource_path ( [string] $resourcefile ) { Join-Path $PSScriptTempRoot $resourcefile } Write-Output \"Launching Up...\" $resourcefileSetup = resource_path ( \"resources/setup.ps1\" ) $resourcefileClean = resource_path ( \"resources/clean.ps1\" ) . $resourcefileSetup -Id \"1.2.3\" . $resourcefileClean setup.ps1 param ( $Id ) Write-Output \"$Id Setting Up...\" clean.ps1 Write-Output \"Cleaning Up...\" Now compress this resources directory to a zip file and build the executable. psburn create app.ps1 --embed-resources psburn build app.ps1 app.cs -r resources.zip Now if you run compiled executable, you will see this output. Launching Up... 1.2.3 Setting Up... Cleaning Up...","title":"Invoke Sub Scripts"},{"location":"usage/embeddingresources/invokesubscripts/#invoke-sub-scripts","text":"You can also invoke multiple sub scripts from a single executable by using $Executable in your powershell script which stores the path for powershell executable.","title":"Invoke Sub Scripts"},{"location":"usage/embeddingresources/invokesubscripts/#test","text":"Create directory structure like this. app.ps1 # main psscript resources/ setup.ps1 # sub script 1 clean.ps1 # sub script 2 Contents of scripts. app.ps1 function resource_path ( [string] $resourcefile ) { Join-Path $PSScriptTempRoot $resourcefile } Write-Output \"Launching Up...\" $resourcefileSetup = resource_path ( \"resources/setup.ps1\" ) $resourcefileClean = resource_path ( \"resources/clean.ps1\" ) . $resourcefileSetup -Id \"1.2.3\" . $resourcefileClean setup.ps1 param ( $Id ) Write-Output \"$Id Setting Up...\" clean.ps1 Write-Output \"Cleaning Up...\" Now compress this resources directory to a zip file and build the executable. psburn create app.ps1 --embed-resources psburn build app.ps1 app.cs -r resources.zip Now if you run compiled executable, you will see this output. Launching Up... 1.2.3 Setting Up... Cleaning Up...","title":"Test"}]}